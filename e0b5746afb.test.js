// Test generated by RoostGPT for test ExpressJs using AI Type Open AI and AI Model gpt-4

import { request } from 'supertest';
import { express } from "express";
import { path } from "path";
import { mongoose } from "mongoose";
import { cookieParser } from "cookie-parser";
import { jwt } from "jsonwebtoken";
import { bcrypt } from "bcrypt"; 
import { User } from './models/user';
import { app } from './index';

jest.mock('./models/user');

describe('POST /register', () => {
  beforeAll(() => {
    mongoose.connect('mongodb://localhost/testDatabase', { useNewUrlParser: true, useUnifiedTopology: true });
  });

  afterEach(() => {
    User.findOne.mockClear();
    User.create.mockClear();
  });

  afterAll(() => {
    mongoose.connection.close();
  });

  test('Should register new user and redirect to home', async () => {
    const hashedPassword = await bcrypt.hash('password', 10);
    User.findOne.mockResolvedValue(null);
    User.create.mockResolvedValue({
      _id: 'testId',
      name: 'test',
      email: 'test@example.com',
      password: hashedPassword
    });

    const response = await request(app)
      .post('/register')
      .send({
        name: 'test',
        email: 'test@example.com',
        password: 'password'
      });

    expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
    expect(User.create).toHaveBeenCalledWith({
      name: 'test',
      email: 'test@example.com',
      password: hashedPassword
    });
    expect(response.header['set-cookie']).toEqual(expect.arrayContaining([expect.stringMatching(/^token=.+/)]));
    expect(response.header.location).toBe('/');
    expect(response.status).toBe(302);
  });

  test('Should fail if user already exists', async () => {
    User.findOne.mockResolvedValue({
      _id: 'testId',
      name: 'test',
      email: 'test@example.com',
      password: 'hashedPassword'
    });

    const response = await request(app)
      .post('/register')
      .send({
        name: 'test',
        email: 'test@example.com',
        password: 'password'
      });

    expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
    expect(User.create).not.toHaveBeenCalled();
    expect(response.header.location).toBe('/login');
    expect(response.status).toBe(302);
  });
});
